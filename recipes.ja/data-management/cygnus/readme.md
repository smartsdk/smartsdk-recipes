# Cygnus

ここでは、Cygnus、特に cygnus-ngsi のさまざまな用途を対象としたレシピを見つける
ことができます。すでに Cygnus に精通していると仮定しますが、そうでない場合は、
[公式ドキュメント](http://fiware-cygnus.readthedocs.io/en/latest/index.html)を
参照してください。

これらのレシピをテストするための環境の準備方法については、ドキュメントの
[インストール](../../installation.md)セクションに記載されています。


## HA に関するいくつかの考察

最初に留意すべき点は、cygnus を使用して高可用性について話す場合、cygnus
 エージェントが処理したデータが最終的なストレージ・ソリューションにドロップ
される前に、そのデータの可用性を言及することです。したがって、
[公式ドキュメント](http://fiware-cygnus.readthedocs.io/en/latest/index.html)に
記載のとおり、さまざまなシンクによって、さまざまなストレージ・ソリューション
 (mongodb, mysql, hdfs など) で永続性を持たせることができます。永続化された
データを HA モードに維持することは、異なる課題であり、実装は使用される
ソリューションに依存します。MongoDB の場合、[MongoDB Replicaset Recipe](../../utils/mongo-replicaset/readme.md)
 を見ることができます。だから、このレシピはいくつかのバックエンドに接続する方法
を示しますが、それらを管理する方法はあなた次第です。

さらに、エージェントを単一の構成可能なエンティティとして展開する方法についても
説明します。しかし、エージェント内には、[Advanced Cygnus Architectures](http://fiware-cygnus.readthedocs.io/en/latest/architecture/index.html#advanced-cygnus-architectures)
 で説明されているように、複数の利用可能な構成 (単一または複数のソース、
チャネル、およびシンクを使用) が存在することに注意してください。これらの内部拡張
アーキテクチャのセットアップ方法とそれぞれの利点については、公式ドキュメントです
でに説明しているため、ここでは説明しません。

Cygnus をデプロイするためには、ステートレスまたはステートフルなサービスかどうか
を理解する必要があります。エージェントのソース部分とシンク部分はデータを保持
しませんが、データが処理されてシンクによってチャネルから取り出されるまで、
チャネルは少なくとも短期間は実行されます。Cygnus と Flume のドキュメントから
読むことができるように、チャンネルは MemoryChannel と FileChannel の形式で
提供されます。

MemoryChannel とバッチ処理では、イベントがチャネルから取り出される前に
エージェントがクラッシュした場合など、データ損失の可能性があります。事実、
各イベントのストレージへのアクセスを避けるため、Cygnus にはバッチ・サイズと
バッチ・フラッシュ・タイムアウトのデフォルト値が付属しています。副次的なことは、
ダイナミックな要求に応じて動的に変更することができればうれしいことですが、これは
後で検討するのは興味深い点です。

したがって、FileChannel を使用すると、レイテンシを犠牲にして、"処理中のデータ
 (inflight data)"に永続性を持たせることができ、この方法では、エージェントで
ソフトウェアの障害/クラッシュが発生した場合に完全な損失を防ぐことができます。
ただし、コンテナ内のこのファイルの場所はカスタマイズ可能ではないため、コンテナの
クラッシュによってフラッシュされない値が失われることに注意してください。

これらのチャネルをどこか別の場所に維持する方法や、異なるコンテナにまたがって
チャネルを共有する方法を模索することができます。あるいは、Solace のような
メッセージ・ベースのソリューションをチャネル・レベルで使用することを探している
かもしれません。しかし、もちろんこれには、このプロジェクトの範囲を超えていて、
Cygnus に対するいくつかの更新が必要です。
